import asyncio
from playwright.async_api import async_playwright

async def run():
    async with async_playwright() as p:
        print("üé≠ Launching browser...")
        # Headless=True for CI/Background execution
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()
        
        # 1. Start at Spanish Intro
        url_es = "http://127.0.0.1:8000/es/intro.html"
        print(f"üåç Navigating to ES: {url_es}...")
        try:
            await page.goto(url_es, timeout=10000)
        except Exception as e:
            print(f"‚ùå Could not connect to {url_es}. Is preview running?")
            await browser.close()
            return

        # Check title or unique content in Spanish
        title_es = await page.title()
        print(f"   Title (ES): {title_es}")
        
        # 2. Find Language Switcher
        print("üëÜ Looking for language switcher...")
        # The dropdown usually has a button. Depending on the theme, it might be:
        # ".article-header-buttons .dropdown-toggle" or similar.
        # We look for text "English" or "en" inside a link or button if dropdown logic is tricky.
        
        # Strategy: Look for the specific link generated by our script
        # Our script generates languages.json which the JS uses to build the menu.
        # Usually it renders as links.
        
        # Try to find the dropdown button first to open it
        try:
            # Specific selector for our language button
            dropdown_btn = await page.wait_for_selector(".teachbook-lang-btn", timeout=3000)
            if dropdown_btn:
                print("   Found Language Switcher button. Clicking...")
                await dropdown_btn.click()
        except:
            print("   Dropdown button not found or not needed. Searching for links directly...")

        # 3. Click English
        print("üñ±Ô∏è Clicking 'English'...")
        # Look for a link with text "English"
        try:
            # We use a robust text selector
            en_link = await page.wait_for_selector("a:text('English')", timeout=2000)
            await en_link.click()
        except:
             print("‚ùå Could not find 'English' link. Checking page content for debugging...")
             content = await page.content()
             # print(content[:500])
             await browser.close()
             return

        # 4. Verify URL change
        await page.wait_for_load_state("networkidle")
        current_url = page.url
        print(f"üîó New URL: {current_url}")
        
        if "/en/" in current_url:
            print("‚úÖ SUCCESS: Switched to English version.")
        else:
            print("‚ùå FAILURE: URL does not contain '/en/'.")

        # 5. Verify Content (English)
        # Check for specific English strings
        # e.g., "Welcome" or "Table of Contents" vs "Tabla de contenido"
        # Let's check the title again
        title_en = await page.title()
        print(f"   Title (EN): {title_en}")

        # 6. Switch back to Spanish
        print("üîÑ Switching back to Spanish...")
        # Re-open dropdown if needed (likely needed after page reload)
        try:
            # Use the robust class we verify earlier
            dropdown_btn = await page.wait_for_selector(".teachbook-lang-btn", timeout=5000)
            if dropdown_btn:
                await dropdown_btn.click()
        except:
            pass

        try:
            es_link = await page.wait_for_selector("a:text('Espa√±ol')", timeout=5000)
            await es_link.click()
        except:
             print("‚ùå Could not find 'Espa√±ol' link.")

        await page.wait_for_load_state("networkidle")
        final_url = page.url
        print(f"üîó Final URL: {final_url}")

        if "/es/" in final_url:
             print("‚úÖ SUCCESS: Switched back to Spanish.")
        else:
             print("‚ùå FAILURE: URL did not return to '/es/'.")

        await browser.close()

if __name__ == "__main__":
    import sys
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    asyncio.run(run())
