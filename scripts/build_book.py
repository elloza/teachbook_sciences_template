import subprocess
import sys
import os
import glob

def fix_pdf_paths():
    """Fixes relative paths for the PDF download button in all HTML files."""
    build_dir = os.path.join("book", "_build", "html")
    pdf_filename = "teachbook.pdf"
    
    print("üîß Corrigiendo rutas del bot√≥n PDF...")
    
    for html_file in glob.glob(os.path.join(build_dir, "**", "*.html"), recursive=True):
        # Calculate relative path to _static from this file
        rel_to_root = os.path.relpath(build_dir, os.path.dirname(html_file))
        if rel_to_root == ".":
            correct_path = f"_static/{pdf_filename}"
        else:
            correct_path = f"{rel_to_root}/_static/{pdf_filename}".replace("\\", "/")
        
        with open(html_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Replace the hardcoded _static path with the relative one
        # Specifically targeting the icon-link generated by sphinx
        new_content = content.replace('href="_static/teachbook.pdf"', f'href="{correct_path}"')
        
        if new_content != content:
            with open(html_file, 'w', encoding='utf-8') as f:
                f.write(new_content)

def main():
    print("üìö Iniciando compilaci√≥n del libro...")
    
    # Command to build the book
    cmd = ["jupyter-book", "build", "book/"]
    
    try:
        # Run build command
        # shell=True is sometimes needed on Windows for entry points
        subprocess.check_call(cmd, shell=True)
        
        # Post-process paths
        fix_pdf_paths()
        
        # Get absolute path to index.html
        build_path = os.path.abspath(os.path.join("book", "_build", "html", "index.html"))
        
        print("\n‚úÖ ¬°Libro compilado con √©xito!")
        print(f"üåç Puedes verlo en: {build_path}")
        
    except subprocess.CalledProcessError:
        print("\n‚ùå Error durante la compilaci√≥n.")
        print("Revise los mensajes de error anteriores.")
        sys.exit(1)

if __name__ == "__main__":
    main()
